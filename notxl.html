<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Notxl - CSV editor</title>
    <style>
        body {
            margin: 0;
        }
        .main-container {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow-y: hidden;
        }
        .tableview-canvas {
            backface-visibility: hidden;
            image-rendering: pixelated;
            transform: translateZ(0);
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        .text-editor {
            position: absolute;
            left: 0;
            border: none;
            overflow: hidden;
            white-space: pre;
            resize: none;
            background: rgb(255, 238, 170);
            outline: none;
        }
        .filter-list {
            position: fixed;
            bottom: 0;
            padding: 1px;
            box-sizing: border-box;
            width: 100vw;
        }
        .filter-line {
            white-space: nowrap;
        }
        .filter-add {
            float: right;
            outline: none;
            cursor: pointer;
            margin: 2px;
            border: none;
            padding: 6px;
            border-radius: 2px;
            background: #fa6;
        }
        .filter-add>i {
            color: lightgray;
            font-style: normal;
        }
        .filter-remove {
            border-radius: 100px;
            border: none;
            margin: 6px -23px;
            background: #fa6;
            line-height: 12px;
        }
        .filter-remove:hover {
            background: #fff;
        }
        .filter-title {
            width: 80px;
            padding: 6px;
            text-align: right;
            font-family: monospace;
            color: #666;
            display: inline-block;
            background: #fa6;
            border-top-left-radius: 2px;
            border-bottom-left-radius: 2px;
        }
        .filter-input {
            width: calc(100% - 320px);
            background: #eee;
            padding: 6px;
            font-family: monospace;
            box-sizing: border-box;
            border: none;
            outline: none;
            margin-bottom: 1px;
            border-top-right-radius: 2px;
            border-bottom-right-radius: 2px;
        }
        .filter-input:focus {
            background: #fea;
        }
        .filter-input.invalid {
            background-color: #fdd;
        }
        .dropzone {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            color: silver;
            text-align: center;
            z-index: 9999;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 18px;
        }
        .drop-ready {
            background: rgba(240, 240, 255, 0.8);
        }
        .progress-bar {
            width: 200px;
            height: 4px;
            background: #fea;
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            width: 0%;
            height: 100%;
            background: #fa6;
        }
    </style>
</head>
<body>
    <div class="main-container"></div>
    <script>
        // Конфигурационные константы
        const CONSTANTS = {
            COLORS: {
                'null or empty string object': 'gray',
                'basic string object': 'black',
                'javascript object': 'green',
                'unif resource l': 'navy',
                'datetime': 'green',
                'float': 'blue',
                'int': 'navy',
                'hx': 'green',
                'bool': 'red'
            },
            WIDTHS: {
                'null or empty string object': 3,
                'basic string object': 6,
                'javascript object': 10,
                'unif resource l': 10,
                'datetime': 6,
                'float': 5,
                'int': 3,
                'hx': 4,
                'bool': 6
            },
            MAX_WIDTHS: {
                'null or empty string object': 3,
                'basic string object': 40,
                'javascript object': 30,
                'unif resource l': 30,
                'datetime': 16,
                'float': 10,
                'int': 10,
                'hx': 12,
                'bool': 6
            },
            LINE_HEIGHT: 24,
            PADDING: 6,
            SCROLLBAR_WIDTH: 10
        };

        // Утилиты для работы с CSV
        class CSVParser {
            static parseCSV(text) {
                text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n'); // Нормализуем переносы
                
                const lines = [];
                let currentLine = [];
                let currentField = '';
                let inQuotes = false;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    
                    if (char === '"') {
                        if (inQuotes && text[i+1] === '"') {
                            currentField += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if ((char === ',' || char === '\t' || char === ';') && !inQuotes) {
                        currentField = currentField.replace(/[\n\r]/g, ' ').trim();
                        currentLine.push(currentField);
                        currentField = '';
                    } else if (char === '\n' && !inQuotes) {
                        currentField = currentField.replace(/[\n\r]/g, ' ').trim();
                        currentLine.push(currentField);
                        lines.push(currentLine);
                        currentLine = [];
                        currentField = '';
                    } else {
                        currentField += char;
                    }
                }
                
                if (currentField !== '' || text[text.length-1] === ',') {
                    currentField = currentField.replace(/[\n\r]/g, ' ').trim();
                    currentLine.push(currentField);
                }
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }
                
                return lines;
            }

            static getType(val) {
                if (typeof(val) !== 'string') {
                    val = '' + val;
                }
                if (val === 'null' || val === 'undefined') {
                    return 'null or empty string object';
                }
                let detected = 'basic string object';
                try {
                    JSON.parse(val);
                    detected = 'javascript object';
                } catch (e) {}
                try {
                    new URL(val);
                    detected = 'unif resource l';
                } catch (e) {}
                if (new Date(val) instanceof Date && !isNaN(new Date(val))) detected = 'datetime';
                if (/^\d+\.\d+$/.test(val)) detected = 'float';
                if (parseInt(val) == val) detected = 'int';
                if (val[0] === '0' && parseInt(val, 16) == val) detected = 'hx';
                if (val.toLowerCase() === 'true' || val.toLowerCase() === 'false') detected = 'b';

                return detected;
            }

            static parseTypes(lines) {
                let types = [];
                for (let j = 0; j < lines[0].length; j++) {
                    types.push('b');
                }
                for (let i = 1; i < Math.min(100, lines.length); i++) {
                    let items = lines[i];
                    for (let j = 0; j < items.length; j++) {
                        let type = this.getType(items[j]);
                        if (!types[j] || types[j].length < type.length) {
                            types[j] = type;
                        }
                    }
                }
                return types;
            }
        }

        // Текстовый редактор для редактирования ячеек
        class TextEditor {
            constructor(container = document.body) {
                this.textarea = document.createElement('textarea');
                this.textarea.className = 'text-editor';
                container.appendChild(this.textarea);
                this.textarea.hidden = true;
                this.editStart = -1;
                this.editEnd = -1;
                
                // Настройка стилей
                const fontSize = ((CONSTANTS.LINE_HEIGHT - CONSTANTS.PADDING * 2) | 0) + 'px';
                this.textarea.style['font-size'] = fontSize;
                
                this.textarea.style['padding'] = `0 ${CONSTANTS.PADDING}px`;
                this.textarea.style['line-height'] = CONSTANTS.LINE_HEIGHT + 'px';
                
                // Обработчики событий
                this.textarea.addEventListener('change', () => this.applyChanges());
                this.textarea.addEventListener('keydown', (e) => this.handleKeyDown(e));
                this.textarea.addEventListener('paste', e => this.handlePaste(e));
            }

            formatCells(content, widths) {
                return content.map(line => {
                    return line.map((cell, index) => {
                        const cellText = String(cell || '');
                        const targetWidth = widths[index] || cellText.length;
                        
                        // Выравниваем текст без добавления запятой
                        return cellText.padEnd(targetWidth);
                    }).join(','); // Добавляем запятые только между ячейками
                }).join('\n');
            }

            showEditArea(position, size, content, widths) {
                this.textarea.hidden = false;
                this.textarea.style.width = size.width + 'px';
                this.textarea.style.top = position.top + 'px';
                this.textarea.style.height = size.height + 'px';
                if (content) {
                    const cleanedContent = content.map(line => 
                        line.map(cell => String(cell || '').replace(/[\n,]/g, '').trim())
                    );
                    
                    this.textarea.value = this.formatCells(cleanedContent, widths);
                }
                this.textarea.focus();
                this.textarea.select();

                this.onEditorOpen?.();
            }

            hide() {
                this.textarea.hidden = true;
            }

            isOpen() {
                return !this.textarea.hidden;
            }

            setEditRange(start, end) {
                this.editStart = start;
                this.editEnd = end;
            }

            applyChanges() {
                if (this.textarea.hidden) return;
                this.hide();

                if (this.onEditorChange) {
                    let lines = CSVParser.parseCSV(this.textarea.value);
                    this.onEditorChange(lines);
                }
            }

            handleKeyDown(e) {
                if (e.key == 'Tab') {
                    e.preventDefault();
                    var start = this.textarea.selectionStart;
                    var end = this.textarea.selectionEnd;
                    // set textarea value to: text before caret + tab + text after caret
                    this.textarea.value = this.textarea.value.substring(0, start) + "\t" + this.textarea.value.substring(end);
                    // put caret at right position again
                    this.textarea.selectionStart = this.textarea.selectionEnd = start + 1;
                }

                if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    this.applyChanges();
                } else if (e.key === "Enter" || e.key === "Backspace") {
                    this.resize();
                } else if (e.key === 'Escape') {
                    this.hide();
                }
            }

            resize() {
                setTimeout(() => {
                    const linesCount = this.textarea.value.split('\n').length;
                    this.textarea.style.height = (linesCount * CONSTANTS.LINE_HEIGHT) + 'px';
                }, 1);
            }

            handlePaste(e) {
                const pastedText = e.clipboardData.getData('text/plain');
                
                let maxLines = Math.floor(window.innerHeight / CONSTANTS.LINE_HEIGHT);
                if (pastedText.split('\n').length > 5) {
                    e.preventDefault();
                    
                    const currentValue = this.textarea.value;
                    const beforeSelection = currentValue.substring(0, this.textarea.selectionStart);
                    const afterSelection = currentValue.substring(this.textarea.selectionEnd);
                    let result = beforeSelection + pastedText + afterSelection;

                    if (this.onEditorChange) {
                        let lines = CSVParser.parseCSV(result);
                        this.hide();
                        this.onEditorChange(lines);
                        return;
                    }
                }
                // Для небольших вставок - стандартное поведение
                this.resize();
            }
        }

        class InputWithAutocomplete {
            constructor(container, className, placeholder = '...') {
                this.input = document.createElement('input');
                this.input.type = 'text';
                this.input.className = className;
                this.input.placeholder = placeholder;
                
                container.appendChild(this.input);

                this.autocomplete = [];

                this.input.addEventListener('keyup', e => {
                    if (e.key.startsWith('Arrow')) return;

                    if (e.key !== 'Backspace') {
                        let incomplete = this.suggest();

                        if (!incomplete) {
                            this.fixTypos();
                        }
                    }

                    let isValid = this.onChange(this.input.value);
                    this.input.classList.toggle('invalid', !isValid && this.input.value);
                });
            }

            suggest() {
                const cursorPos = this.input.selectionStart;
                const fullText = this.input.value;

                if (cursorPos < fullText.length && fullText[cursorPos].match(/[\w"']/)) {
                    return false;
                }
                
                const textBeforeCursor = fullText.substring(0, cursorPos);
                const textAfterCursor = fullText.substring(cursorPos);
                const wordMatch = textBeforeCursor.match(/([\w"']+)$/);
                if (!wordMatch) return;

                const partialWord = wordMatch[1];
                const wordStart = wordMatch.index;
                
                for (let item of this.autocomplete) {
                    if (item.toLowerCase().startsWith(partialWord.toLowerCase())) {
                        const rest = item.substring(partialWord.length);
                        
                        this.input.value = textBeforeCursor + rest + textAfterCursor;
                        this.input.setSelectionRange(
                            wordStart + partialWord.length, 
                            wordStart + item.length,
                            'backward' // Выделение в обратном направлении (для удобства замены)
                        );
                        
                        return true;
                    }
                }
            }

            fixTypos() {
                const text = this.input.value;
                let result = '';
                let currentWord = '';

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    
                    // Если это буква - добавляем к текущему слову
                    if (/[a-zA-Z]/.test(char)) {
                        currentWord += char;
                    } else {
                        // Если нашли не-буквенный символ - обрабатываем накопленное слово
                        if (currentWord) {
                            result += this.correctWord(currentWord);
                            currentWord = '';
                        }
                        result += char; // Добавляем сам символ без изменений
                    }
                }

                // Обрабатываем последнее слово, если оно есть
                if (currentWord) {
                    result += this.correctWord(currentWord);
                }

                this.input.value = result;
            }

            correctWord(word) {
                // Ищем точное совпадение без учета регистра
                for (let item of this.autocomplete) {
                    if (item.toLowerCase() === word.toLowerCase()) {
                        return item; // Возвращаем слово с правильным регистром
                    }
                }

                // Ищем похожие слова (максимум 1 опечатка)
                let bestMatch = null;
                let minDistance = Infinity;

                for (let item of this.autocomplete) {
                    const distance = this.levenshteinDistance(word.toLowerCase(), item.toLowerCase());
                    if (distance < minDistance && distance <= 1) {
                        minDistance = distance;
                        bestMatch = item;
                    }
                }

                return bestMatch || word; // Возвращаем исправленное слово или оригинал, если не нашли совпадения
            }

            // Алгоритм Левенштейна для поиска расстояния между строками
            levenshteinDistance(a, b) {
                const matrix = [];
                
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i-1) === a.charAt(j-1)) {
                            matrix[i][j] = matrix[i-1][j-1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i-1][j-1] + 1,
                                matrix[i][j-1] + 1,
                                matrix[i-1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[b.length][a.length];
            }

            setAutocompleteList(arr) {
                arr = arr.map(item => item.trim());
                this.autocomplete = arr;
            }
        }

        class FilterList {
            constructor(container = document.body) {
                this.filters = [];
                this.availableFields = [];

                this.div = document.createElement('div');
                this.div.className = 'filter-list';
                container.appendChild(this.div);

                let openFilterBtn = document.createElement('button');
                openFilterBtn.innerHTML = '<i>ctrl</i>+Filter';
                openFilterBtn.className = 'filter-add';
                this.div.appendChild(openFilterBtn);
                openFilterBtn.onclick = (e) => {
                    this.toggleFilter();
                };

                let addColumnBtn = document.createElement('button');
                addColumnBtn.innerHTML = '<i>ctrl</i>+Extend';
                addColumnBtn.className = 'filter-add';
                this.div.appendChild(addColumnBtn);
                addColumnBtn.onclick = (e) => {
                    this.addLine(this.genColumnPlaceholder(), 'Column:');
                };

                this.filterLine = this.addLine('*', 'Filter:', false);
                this.filterLine.button.onclick = false;
                this.filterLine.button.innerText = '';
                this.filterLine.container.hidden = true;
            }

            toggleFilter() {
                this.filterLine.container.hidden = false;
                this.filterLine.input.focus();
                this.filterLine.input.select();
            }

            hide() {
                this.filterLine.container.hidden = true;
            }

            setFilteredCount(count) {
                if (count >= 0) {
                    this.filterLine.button.innerText = count;
                } else {
                    this.filterLine.button.innerText = 'err';
                }
            }

            addLine(placeholder, title, needAutocomplete = true) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'filter-line';

                const titleSpan = document.createElement('span');
                titleSpan.className = 'filter-title';
                titleSpan.innerText = title;
                lineDiv.appendChild(titleSpan);

                // Поле фильтра
                const filter = new InputWithAutocomplete(lineDiv, 'filter-input', placeholder);
                filter.setAutocompleteList(this.availableFields);
                filter.onChange = () => this.refilter();
                
                // Кнопка удаления
                const removeBtn = document.createElement('button');
                removeBtn.textContent = '×';
                removeBtn.className = 'filter-remove';
                removeBtn.onclick = () => {
                    if (filter === this.filterLine) {
                        this.filterLine = null;
                    }
                    lineDiv.remove();
                    this.refilter();
                };

                lineDiv.appendChild(removeBtn);
                filter.button = removeBtn;

                this.div.appendChild(lineDiv);

                if (needAutocomplete) {
                    this.filters.push(filter);
                }

                filter.input.focus();
                filter.input.select();
                filter.container = lineDiv;
                filter.title = titleSpan;

                return filter;
            }

            refilter() {
                let code = '';
                let newVars = new Set();
                let wildcardFilter = this.filterLine.input.value;

                for (let filter of this.filters) {
                    let filterStr = filter.input.value;
                    filter.title.innerText = 'Column:';

                    if (filterStr) {
                        let newVar = this.getNewVariableName(filterStr);
                        if (!newVar) {
                        } else {
                            filter.title.innerText = newVar + ':';
                            newVars.add(newVar);
                            code += filterStr + ';\n';
                        }
                    }
                }

                return this.onFilterListChange(wildcardFilter, code, Array.from(newVars));
            }

            getNewVariableName(filterStr) {
                let eqInd = filterStr.indexOf('=');
                if (eqInd !== -1) {
                    if (filterStr[eqInd + 1] !== '=') {
                        let name = filterStr.substr(0, eqInd).trim();
                        if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
                            return name;
                        }
                    }
                }
            }

            setAutocompleteList(arr) {
                this.availableFields = arr;

                for (let filter of this.filters) {
                    if (typeof(filter.setAutocompleteList) !== 'function') debugger
                    filter.setAutocompleteList(arr);
                }
            }

            genFilterPlaceholder() {
                let fields = this.availableFields;
                if (fields.length === 0) fields = ['Area', 'Bids', 'Count', 'Quality', 'Items'];

                let text = '';

                function rnd() {
                    return arguments[Math.floor(Math.random() * arguments.length)];
                };

                for (let i = 0; i < rnd(1, 2, 3, 5); i++) {
                    if (rnd(true, false)) {
                        let field = rnd(...fields);
                        let op = rnd('==("', '!=("', '.includes("');
                        let val = rnd(field.toLowerCase().substr(0, 2), 'text', 'str');
                        text += field + op + val + '")';
                    } else {
                        let field = rnd(...fields);
                        let op = rnd('==', '!=', '>', '<', '>=', '<=');
                        let val = (Math.random() * 100).toFixed(rnd(0, 0, 2));
                        text += field + op + val;
                    }
                    text += rnd(' && ', ' || ');
                }
                return text.substr(0, text.length - 4);
            }

            genColumnPlaceholder() {
                let fields = this.availableFields;
                if (fields.length === 0) fields = ['Area', 'Bids', 'Count', 'Quality', 'Items'];

                function rnd() {
                    return arguments[Math.floor(Math.random() * arguments.length)];
                };

                let name = rnd('Total', 'NewColumn', ...fields.map(name => name + (this.filters.length + 1)));

                let text = name + ' = ';

                let dot = rnd(0, 0, 2);

                for (let i = 0; i < rnd(1, 2, 3, 5); i++) {
                    let field = rnd(...fields);
                    let op = rnd('*', '/', '*', '/', '**', '%');
                    let val = (Math.random() * 100).toFixed(dot);
                    text += field + op + val;
                    text += rnd(' + ', ' - ');
                }
                return text.substr(0, text.length - 3);
            }

            applyWildcardFilter(lines, filterStr) {
                const parts = filterStr.split('*').map(part => part.toLowerCase()).filter(part => part !== '');
                
                let newTable = [lines[0] || []],
                    indexMap = [0];

                if (parts.length === 0) {
                    return { lines: newTable, indexMap: null };
                }

                for (let i = 1; i < lines.length; i++) {
                    const lineString = lines[i].join(',').toLowerCase();
                    
                    let currentIndex = 0;
                    let allPartsFound = true;

                    for (const part of parts) {
                        const foundIndex = lineString.indexOf(part, currentIndex);
                        if (foundIndex === -1) {
                            allPartsFound = false;
                            break;
                        }
                        currentIndex = foundIndex + part.length;
                    }

                    if (allPartsFound) {
                        newTable.push(lines[i]);
                        indexMap.push(i);
                    }
                }

                return { lines: newTable, indexMap: indexMap };
            }

        }


        // Основной компонент таблицы
        class TableView {
            constructor(container = document.body) {
                this.canvas = document.createElement('canvas');
                this.canvas.className = 'tableview-canvas';
                container.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');
                
                this.lines = [];
                this.types = [];
                this.indexMap = [];
                this.offsetLine = 0;
                this.selectionStart = -1;
                this.selectionEnd = -1;
                this.scrolling = false;
                this.charWidth = null;
                this.maxLines = null;
                
                // Настройка контекста
                this.ctx.imageSmoothingEnabled = false;

                const fontSize = CONSTANTS.LINE_HEIGHT - CONSTANTS.PADDING * 2;
                this.ctx.font = fontSize + 'px monospace';
                this.charWidth = this.ctx.measureText('M').width;
            }

            init() {
                this.onResize();
                window.addEventListener('resize', () => this.onResize());
            }

            setCanvasSizeRetina(width, height) {
                const pixelRatio = window.devicePixelRatio || 1;
                // Устанавливаем внутреннее разрешение с учетом pixelRatio
                this.canvas.width = width * pixelRatio;
                this.canvas.height = height * pixelRatio;
                
                // Устанавливаем CSS размеры
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
                
                // Масштабируем контекст
                this.ctx.scale(pixelRatio, pixelRatio);
                this.ctx.imageSmoothingEnabled = false;
                
                // Сохраняем размеры для расчетов
                this.displayWidth = width;
                this.displayHeight = height;
                
                // Пересчитываем максимальное количество строк
                this.maxLines = Math.floor(height / CONSTANTS.LINE_HEIGHT);
            }

            onResize() {
                const container = this.canvas.parentElement;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                this.setCanvasSizeRetina(containerWidth, containerHeight);
                
                // Пересчитываем charWidth после изменения размера
                const fontSize = CONSTANTS.LINE_HEIGHT - CONSTANTS.PADDING * 2;
                this.ctx.font = fontSize + 'px monospace';
                this.charWidth = this.ctx.measureText('M').width;
                console.log(this.charWidth)
                
                this.draw();
            }

            setLines(lines, types, indexMap) {
                this.lines = lines;
                this.types = types;
                this.indexMap = indexMap || Array.from({ length: lines.length }, (_, i) => i);
                this.draw();
            }

            draw() {
                this.canvas.width = this.canvas.width;

                if (!this.lines || !this.types) return;
                if (!this.lines.length || !this.types.length) return;
                
                const widths = [];
                const colors = [];
                const maxWidths = [];
                
                // Подготовка данных для отрисовки
                for (let type of this.types) {
                    widths.push(CONSTANTS.WIDTHS[type] || 10);
                    maxWidths.push(CONSTANTS.MAX_WIDTHS[type] || 30);
                    colors.push(CONSTANTS.COLORS[type] || 'black');
                }
                
                // Корректировка ширины столбцов
                this.correctWidths(widths, maxWidths);
                
                // Расчет полной ширины таблицы
                let totalWidth = CONSTANTS.PADDING * 2 + (this.charWidth | 0) * widths.length + 
                                (this.charWidth | 0) * widths.reduce((a, b) => a + b) + 
                                CONSTANTS.SCROLLBAR_WIDTH + 1;

                // Получаем размеры контейнера
                const container = this.canvas.parentElement;
                const containerWidth = container.clientWidth;
                const containerHeight = container.clientHeight;
                
                // Устанавливаем размеры канваса - либо полная ширина таблицы, либо ширина контейнера
                const canvasWidth = Math.max(containerWidth, totalWidth);
                this.setCanvasSizeRetina(canvasWidth, containerHeight);
                
                const fontSize = CONSTANTS.LINE_HEIGHT - CONSTANTS.PADDING * 2;
                this.ctx.font = fontSize + 'px monospace';

                // Отрисовка заголовка
                const background = this.isSelected(0) ? '#fea' : '#fa6';
                this.drawLine(this.lines[0], 0, [], widths, background);

                let offset = this.getOffset();

                // Отрисовка строк данных
                for (let i = 1; i < Math.min(this.maxLines + 1, this.lines.length - offset); i++) {
                    const lineIndex = i + offset;
                    const background = this.isSelected(lineIndex) ? '#fea' : 'white';

                    this.drawLine(this.lines[lineIndex], CONSTANTS.LINE_HEIGHT * i, colors, widths, background);
                }
                
                // Отрисовка скроллбара
                this.drawScrollbar();
            }

            getOffset() {
                let offset = this.offsetLine;
                if (offset > this.lines.length - this.maxLines + 1) {
                    offset = this.lines.length - this.maxLines + 1;
                }
                if (offset < 0) {
                    offset = 0;
                }
                return offset;
            }

            isSelected(lineIndex) {
                if (this.selectionEnd > this.selectionStart) {
                    return lineIndex >= this.selectionStart && 
                        lineIndex <= this.selectionEnd && 
                        this.selectionStart !== -1;
                } else {
                    return lineIndex <= this.selectionStart && 
                        lineIndex >= this.selectionEnd && 
                        this.selectionStart !== -1;
                }
            }

            correctWidths(widths, maxWidths) {
                // заголовки обрабатываем отдельно
                for (let j = 0; j < 1; j++) {
                    const items = this.lines[j];
                    if (items !== undefined) {
                        for (let i = 0; i < items.length; i++) {
                            let item = '' + items[i];
                            if (widths[i] < item.length) {
                                widths[i] = Math.min(maxWidths[i], item.length);
                            }
                        }
                    }
                }

                let offset = this.getOffset();

                for (let j = offset; j < Math.min(offset + this.maxLines, this.lines.length); j++) {
                    const items = this.lines[j];
                    if (items !== undefined) {
                        for (let i = 0; i < items.length; i++) {
                            let item = '' + items[i];
                            if (widths[i] < item.length) {
                                widths[i] = Math.min(maxWidths[i], item.length);
                            }
                        }
                    }
                }
            }

            drawLine(items, y, colors, widths, background) {
                let x = CONSTANTS.PADDING;
                this.ctx.lineWidth = 1;
                this.ctx.textBaseline = 'top';
                
                // Фон строки
                this.ctx.fillStyle = background;
                this.ctx.fillRect(0, y, 4096, CONSTANTS.LINE_HEIGHT);
                
                // Отрисовка ячеек
                items.forEach((text, i) => {
                    text = '' + text;
                    const color = colors[i] || 'black';
                    const width = widths[i] || 20;
                    const displayText = text.length > width ? text.substring(0, width - 1) + '…' : text;
                    
                    this.ctx.fillStyle = color;
                    this.ctx.fillText(
                        displayText, 
                        Math.floor(x) + 0.5,
                        Math.floor(y + 1 + CONSTANTS.PADDING) + 0.5
                    );
                    
                    x += width * this.charWidth + this.charWidth;
                });
                
                // Разделитель строк
                this.ctx.strokeStyle = '#f0f0f0';
                this.ctx.beginPath();
                this.ctx.moveTo(0, y + CONSTANTS.LINE_HEIGHT - 0.5);
                this.ctx.lineTo(4096, y + CONSTANTS.LINE_HEIGHT);
                this.ctx.stroke(); 
            }

            drawScrollbar() {
                const { canvas, ctx } = this;
                const totalWidth = canvas.width;
                const totalHeight = canvas.height;
                const scrollbarWidth = CONSTANTS.SCROLLBAR_WIDTH;
                const scrollbarHeight = scrollbarWidth * 3;
                
                const percent = this.offsetLine / Math.max(1, this.lines.length - this.maxLines);
                const y = (totalHeight - scrollbarHeight) * percent;
                
                ctx.fillStyle = '#eee';
                ctx.fillRect(totalWidth - scrollbarWidth, 0, scrollbarWidth, totalHeight);
                
                ctx.fillStyle = '#fa6';
                ctx.fillRect(totalWidth - scrollbarWidth, y, scrollbarWidth, scrollbarHeight);
            }

            getLineIndexFromMouse(e) {
                const rect = this.canvas.getBoundingClientRect();
                const y = e.clientY - rect.top;
                let line = Math.floor(y / CONSTANTS.LINE_HEIGHT) + this.offsetLine;
                return Math.min(line, this.lines.length);
            }

            getScrollFromMouse(e) {
                const rect = this.canvas.getBoundingClientRect();
                const y = Math.max(0, Math.min(e.clientY - rect.top, this.canvas.height));
                return Math.floor((y / this.canvas.height) * Math.max(1, this.lines.length - this.maxLines));
            }

            scrollTo(line) {
                this.offsetLine = Math.max(
                    0, 
                    Math.min(this.lines.length - this.maxLines, line)
                );
                this.draw();
            }
        }

        class CSVFileDropzone {
            constructor(container = document.body) {
                this.onDrop = null;
                
                this.dropzone = document.createElement('div');
                this.dropzone.className = 'dropzone';
                this.dropzone.innerText = 'drop .csv here\nmax size 2GB';
                
                container.appendChild(this.dropzone);

                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.dropzone.classList.add('drop-ready');
                });
                
                container.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    this.dropzone.classList.remove('drop-ready');
                });
                
                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.dropzone.classList.remove('drop-ready');
                    this.showProgress();
                    setTimeout((files) => this.handleFileDrop(files), 300, e.dataTransfer.files);
                });
            }
            
            handleFileDrop(files) {
                if (files.length === 0) return;

                const file = files[0];
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    this.dropzone.innerText = 'drop .csv here\nmax size 2GB';
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percent = (e.loaded / e.total) * 100;
                        this.updateProgress(percent);
                    }
                };
                
                reader.onload = (e) => {
                    this.completeProgress(e.target.result);
                };
                
                reader.onerror = (e) => {
                    this.dropzone.innerText = 'drop .csv here\nmax size 2GB';
                };
                
                reader.readAsText(file);
            }

            showProgress() {
                this.dropzone.innerHTML = '<div class="progress-bar"><div class="progress-fill"></div></div>';
                this.progressFill = this.dropzone.querySelector('.progress-fill');
                this.progressFill.style.width = '0%';
            }

            updateProgress(percent) {
                if (this.progressFill) {
                    this.progressFill.style.width = percent + '%';
                }
            }

            completeProgress(data) {
                this.updateProgress(100);
                setTimeout((data) => {
                    this.hide();

                    if (this.onDrop) {
                        this.onDrop(data);
                    }
                }, 300, data);
            }

            hide() {
                this.dropzone.hidden = true;
                this.dropzone.style.display = 'none';
            }
        }

        // Главный контроллер приложения
        class CSVApp {
            constructor(container = document.body) {
                this.lines = [];
                this.types = [];
                this.tableView = new TableView(container);
                this.textEditor = new TextEditor(container);
                this.filterList = new FilterList(container);
                this.dropzone = new CSVFileDropzone(container);

                this.textEditor.onEditorOpen = () => {
                    this.dropzone.hide();
                    this.clearSelection();
                };

                this.textEditor.onEditorChange = (changes) => {
                    this.applyTextChanges(changes);
                };

                this.filterList.onFilterListChange = (newFilter, newColumnsCode, newVars) => {
                    return this.applyFilter(newFilter, newColumnsCode, newVars);
                };

                this.dropzone.onDrop = (text) => {
                    this.dropzone.hide();
                    this.lines = CSVParser.parseCSV(text);
                    this.types = CSVParser.parseTypes(this.lines);
                    this.filterList.refilter();
                    this.filterList.setAutocompleteList(this.lines[0]);
                };

                this.tableView.init();
                
                // Привязка обработчиков событий
                this.tableView.canvas.addEventListener('mousedown', e => this.handleMouseDown(e));
                document.addEventListener('mousemove', e => this.handleMouseMove(e));
                document.addEventListener('mouseup', () => this.handleMouseUp());
                //document.addEventListener('mouseleave', () => this.handleMouseLeave());
                this.tableView.canvas.addEventListener('wheel', e => this.handleWheel(e));
                document.addEventListener('keydown', e => this.handleKeyDown(e));
            }

            clearSelection() {
                this.tableView.selectionStart = -1;
                this.tableView.selectionEnd = -1;
                if (this.tableView.lines) {
                    this.tableView.draw();
                }
            }

            handleMouseDown(e) {
                this.clearSelection();

                if (this.textEditor.isOpen()) {
                    this.textEditor.applyChanges();
                    this.textEditor.hide();
                    this.clearSelection();
                    return;
                }

                // Обработка скроллбара
                let scrollLeft = e.target.parentElement.parentElement.scrollLeft; // document.scrollLeft
                if (e.clientX + scrollLeft > e.target.width - CONSTANTS.SCROLLBAR_WIDTH * 4) {
                    this.tableView.scrolling = true;
                    this.tableView.offsetLine = this.tableView.getScrollFromMouse(e);
                    this.tableView.draw();
                    return;
                }

                // Выделение строки
                this.tableView.selectionStart = this.tableView.getLineIndexFromMouse(e);
                this.tableView.selectionEnd = this.tableView.selectionStart;
                this.tableView.draw();
            }

            handleMouseMove(e) {
                if (!this.tableView.lines) return;
                
                // Перетаскивание скроллбара
                if (this.tableView.scrolling) {
                    this.tableView.offsetLine = this.tableView.getScrollFromMouse(e);
                    this.tableView.draw();
                    return;
                }

                // Выделение диапазона
                if (this.tableView.selectionStart === -1) return;
                
                const lineIndex = this.tableView.getLineIndexFromMouse(e);
                this.tableView.selectionEnd = lineIndex;
                this.tableView.draw();
            }

            handleMouseUp() {
                if (this.tableView.scrolling) {
                    this.tableView.scrolling = false;
                    return;
                }

                if (this.tableView.selectionStart === -1) return;
                
                // Нормализация диапазона выделения
                if (this.tableView.selectionEnd < this.tableView.selectionStart) {
                    [this.tableView.selectionStart, this.tableView.selectionEnd] = 
                    [this.tableView.selectionEnd, this.tableView.selectionStart];
                }

                // Показ редактора
                this.showEditor();
            }

            showEditor() {
                const { selectionStart, selectionEnd } = this.tableView;
                // selectionStart/End - это индексы в ОТФИЛЬТРОВАННОМ массиве (tableView.lines)

                // 1. Получаем исходные индексы с помощью indexMap
                const sourceStartIndex = this.tableView.indexMap[selectionStart];
                const sourceEndIndex = this.tableView.indexMap[selectionEnd];

                // 2. Берем данные для редактора из ОТФИЛЬТРОВАННОГО вида (так видит пользователь)
                const lines = this.tableView.lines.slice(selectionStart, selectionEnd + 1);
                
                const position = {
                    top: (selectionStart - this.tableView.offsetLine) * CONSTANTS.LINE_HEIGHT
                };
                
                const size = {
                    width: this.tableView.canvas.width - CONSTANTS.SCROLLBAR_WIDTH - CONSTANTS.PADDING,
                    height: ((selectionEnd - selectionStart + 1) * CONSTANTS.LINE_HEIGHT)
                };

                const widths = [];
                const maxWidths = [];
                
                for (let type of this.types) {
                    widths.push(CONSTANTS.WIDTHS[type] || 10);
                    maxWidths.push(CONSTANTS.MAX_WIDTHS[type] || 30);
                }
                
                this.tableView.correctWidths(widths, maxWidths);
                
                // 3. Но запоминаем в textEditor ИСХОДНЫЕ индексы!
                this.textEditor.setEditRange(sourceStartIndex, sourceEndIndex);
                
                this.textEditor.showEditArea(position, size, lines, widths);
            }

            handleMouseLeave() {
                this.tableView.scrolling = false;
                this.tableView.selectionStart = -1;
                this.tableView.selectionEnd = -1;
                this.textEditor.hide();
                if (this.tableView.lines) this.tableView.draw();
            }

            handleWheel(e) {
                if (e.shiftKey) return;
                e.preventDefault();
                this.textEditor.hide();
                
                if (!this.tableView.lines) return;
                
                const maxOffset = Math.max(0, this.tableView.lines.length - this.tableView.maxLines);
                this.tableView.offsetLine = Math.min(
                    maxOffset, 
                    Math.max(0, this.tableView.offsetLine + Math.sign(e.deltaY))
                );
                
                this.tableView.draw();
            }

            handleKeyDown(e) {
                if (e.ctrlKey && e.code === 'KeyF') {
                    e.preventDefault();
                    this.textEditor.hide();
                    this.filterList.toggleFilter();
                }

                if (e.ctrlKey && e.code === 'KeyE') {
                    e.preventDefault();
                    this.textEditor.hide();
                    this.filterList.addLine(this.filterList.genColumnPlaceholder());
                }

                if (e.code === 'Escape') {
                    this.textEditor.hide();
                    this.filterList.hide();
                }
            }

            applyTextChanges(changes) {
                if (!changes) return;

                const { editStart, editEnd } = this.textEditor;
                const deleteCount = editEnd - editStart + 1;

                // Создаем новый массив, объединяя части старого и новые изменения
                // Это избегает мутаций и потенциально быстрее для очень больших массивов
                this.lines = [
                    ...this.lines.slice(0, editStart),
                    ...changes,
                    ...this.lines.slice(editEnd + 1)
                ];

                this.types = CSVParser.parseTypes(this.lines);
                this.filterList.refilter();
                this.filterList.setAutocompleteList(this.lines[0]);
            }

            applyFilter(newFilter, newColumnsCode, newVars) {
                let lines = this.lines,
                    types = this.types,
                    indexMap,
                    isValid = true;

                if (newColumnsCode) {
                    try {
                        let modifier = this.compile(newColumnsCode, newVars);
                        lines = modifier(this.lines);
                        types = CSVParser.parseTypes(lines);
                    } catch (e) {
                        isValid = false;
                    }
                }

                if (newFilter) {
                    // !!! ВАЖНО: Создаем карту соответствия !!!
                    // Для этого нам нужно знать, какие ИСХОДНЫЕ индексы прошли фильтр.
                    let result = this.filterList.applyWildcardFilter(lines, newFilter);

                    lines = result.lines;
                    indexMap = result.indexMap;
                }

                if (lines) {
                    this.filterList.setFilteredCount(lines.length - 1);
                    this.tableView.setLines(lines, types, indexMap);
                    return isValid;
                }

                this.filterList.setFilteredCount(-1);
                return true;
            }

            compile(userCode, newColumns) {
                if (!this.lines) {
                    return;
                }

                let names = [...this.lines[0]];

                if (newColumns) {
                    for (let name of newColumns) {
                        names.push(name);
                    }
                }

                // Оборачиваем пользовательский код для правильной обработки
                const wrappedCode = `
                    return function processTable(table) {
                        "use strict";
                        let newTable = [[${names.map(name => '"' + name + '"').join(',')}]];
                        for (let i = 1; i < table.length; i++) {
                            let [${names.join(',')}] = table[i];

                            // Пользовательский код выполняется в контексте строки
                            ${userCode}
                            
                            newTable.push([${names.join(',')}]);
                        }
                        return newTable;
                    }
                `;

                return new Function(wrappedCode)();
            }
        }

        // Инициализация приложения
        let app = new CSVApp(document.querySelector('.main-container'));

        let defcsv = `PassengerId,Survived,Pclass,Name,Sex,Age,SibSp,Parch,Ticket,Fare,Cabin,Embarked
1,0,3,"Braund, Mr. Owen Harris",male,22,1,0,A/5 21171,7.25,,S
2,1,1,"Cumings, Mrs. John Bradley (Florence Briggs Thayer)",female,38,1,0,PC 17599,71.2833,C85,C
3,1,3,"Heikkinen, Miss. Laina",female,26,0,0,STON/O2. 3101282,7.925,,S
4,1,1,"Futrelle, Mrs. Jacques Heath (Lily May Peel)",female,35,1,0,113803,53.1,C123,S
5,0,3,"Allen, Mr. William Henry",male,35,0,0,373450,8.05,,S
6,0,3,"Moran, Mr. James",male,,0,0,330877,8.4583,,Q
7,0,1,"McCarthy, Mr. Timothy J",male,54,0,0,17463,51.8625,E46,S
8,0,3,"Palsson, Master. Gosta Leonard",male,2,3,1,349909,21.075,,S
9,1,3,"Johnson, Mrs. Oscar W (Elisabeth Vilhelmina Berg)",female,27,0,2,347742,11.1333,,S
10,1,2,"Nasser, Mrs. Nicholas (Adele Achem)",female,14,1,0,237736,30.0708,,C
11,1,3,"Sandstrom, Miss. Marguerite Rut",female,4,1,1,PP 9549,16.7,G6,S
12,1,1,"Bonnell, Miss. Elizabeth",female,58,0,0,113783,26.55,C103,S
13,0,3,"Saundercock, Mr. William Henry",male,20,0,0,A/5. 2151,8.05,,S
14,0,3,"Andersson, Mr. Anders Johan",male,39,1,5,347082,31.275,,S
15,0,3,"Vestrom, Miss. Hulda Amanda Adolfina",female,14,0,0,350406,7.8542,,S
16,1,2,"Hewlett, Mrs. (Mary D Kingcome) ",female,55,0,0,248706,16,,S
17,0,3,"Rice, Master. Eugene",male,2,4,1,382652,29.125,,Q
18,1,2,"Williams, Mr. Charles Eugene",male,,0,0,244373,13,,S
19,0,3,"Vander Planke, Mrs. Julius (Emelia Maria Vandemoortele)",female,31,1,0,345763,18,,S
20,1,3,"Masselmani, Mrs. Fatima",female,,0,0,2649,7.225,,C
21,0,2,"Fynney, Mr. Joseph J",male,35,0,0,239865,26,,S
22,1,2,"Beesley, Mr. Lawrence",male,34,0,0,248698,13,D56,S
23,1,3,"McGowan, Miss. Anna ""Annie""",female,15,0,0,330923,8.0292,,Q
24,1,1,"Sloper, Mr. William Thompson",male,28,0,0,113788,35.5,A6,S
25,0,3,"Palsson, Miss. Torborg Danira",female,8,3,1,349909,21.075,,S
26,1,3,"Asplund, Mrs. Carl Oscar (Selma Augusta Emilia Johansson)",female,38,1,5,347077,31.3875,,S
27,0,3,"Emir, Mr. Farred Chehab",male,,0,0,2631,7.225,,C
28,0,1,"Fortune, Mr. Charles Alexander",male,19,3,2,19950,263,C23 C25 C27,S
29,1,3,"O'Dwyer, Miss. Ellen ""Nellie""",female,,0,0,330959,7.8792,,Q
30,0,3,"Todoroff, Mr. Lalio",male,,0,0,349216,7.8958,,S
31,0,1,"Uruchurtu, Don. Manuel E",male,40,0,0,PC 17601,27.7208,,C
32,1,1,"Spencer, Mrs. William Augustus (Marie Eugenie)",female,,1,0,PC 17569,146.5208,B78,C
33,1,3,"Glynn, Miss. Mary Agatha",female,,0,0,335677,7.75,,Q
34,0,2,"Wheadon, Mr. Edward H",male,66,0,0,C.A. 24579,10.5,,S
35,0,1,"Meyer, Mr. Edgar Joseph",male,28,1,0,PC 17604,82.1708,,C
36,0,1,"Holverson, Mr. Alexander Oskar",male,42,1,0,113789,52,,S
37,1,3,"Mamee, Mr. Hanna",male,,0,0,2677,7.2292,,C
38,0,3,"Cann, Mr. Ernest Charles",male,21,0,0,A./5. 2152,8.05,,S
39,0,3,"Vander Planke, Miss. Augusta Maria",female,18,2,0,345764,18,,S
40,1,3,"Nicola-Yarred, Miss. Jamila",female,14,1,0,2651,11.2417,,C
41,0,3,"Ahlin, Mrs. Johan (Johanna Persdotter Larsson)",female,40,1,0,7546,9.475,,S
42,0,2,"Turpin, Mrs. William John Robert (Dorothy Ann Wonnacott)",female,27,1,0,11668,21,,S
43,0,3,"Kraeff, Mr. Theodor",male,,0,0,349253,7.8958,,C
44,1,2,"Laroche, Miss. Simonne Marie Anne Andree",female,3,1,2,SC/Paris 2123,41.5792,,C
45,1,3,"Devaney, Miss. Margaret Delia",female,19,0,0,330958,7.8792,,Q
46,0,3,"Rogers, Mr. William John",male,,0,0,S.C./A.4. 23567,8.05,,S
47,0,3,"Lennon, Mr. Denis",male,,1,0,370371,15.5,,Q
48,1,3,"O'Driscoll, Miss. Bridget",female,,0,0,14311,7.75,,Q
49,0,3,"Samaan, Mr. Youssef",male,,2,0,2662,21.6792,,C
50,0,3,"Arnold-Franchi, Mrs. Josef (Josefine Franchi)",female,18,1,0,349237,17.8,,S
51,0,3,"Panula, Master. Juha Niilo",male,7,4,1,3101295,39.6875,,S
52,0,3,"Nosworthy, Mr. Richard Cater",male,21,0,0,A/4. 39886,7.8,,S
53,1,1,"Harper, Mrs. Henry Sleeper (Myna Haxtun)",female,49,1,0,PC 17572,76.7292,D33,C
54,1,2,"Faunthorpe, Mrs. Lizzie (Elizabeth Anne Wilkinson)",female,29,1,0,2926,26,,S
55,0,1,"Ostby, Mr. Engelhart Cornelius",male,65,0,1,113509,61.9792,B30,C
56,1,1,"Woolner, Mr. Hugh",male,,0,0,19947,35.5,C52,S
57,1,2,"Rugg, Miss. Emily",female,21,0,0,C.A. 31026,10.5,,S
58,0,3,"Novel, Mr. Mansouer",male,28.5,0,0,2697,7.2292,,C`;

    app.dropzone.onDrop(defcsv);
    </script>
</body>
</html>
