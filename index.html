<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Notxl - CSV editor</title>
    <style>
        body {
            margin: 0;
        }
        .main-container {
            margin: 0;
            padding: 0;
            width: 100vw;
            height: 100vh;
            overflow-y: hidden;
        }
        .scroll-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            position: fixed;
            top: 0;
        }
        .virtual-area {
            padding-left: 100px;
            padding-bottom: 100px;
            min-width: calc(100% - 100px);
            min-height: calc(100% - 100px);
        }
        .tableview-canvas {
            backface-visibility: hidden;
            transform: translateZ(0);
            pointer-events: none; 
        }
        .text-editor {
            position: absolute;
            left: 0;
            border: none;
            overflow: hidden;
            white-space: pre;
            resize: none;
            background: rgb(255, 238, 170);
            outline: none;
            font-family: monospace;
            min-width: 50%;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .filter-list {
            position: fixed;
            bottom: 0;
            padding: 1px;
            box-sizing: border-box;
            width: 100%;
            padding: 15px;
            pointer-events: none;
        }
        .filter-line {
            white-space: nowrap;
            pointer-events: auto;
        }
        .filter-add {
            float: right;
            outline: none;
            cursor: pointer;
            margin: 2px;
            border: none;
            padding: 6px;
            border-radius: 2px;
            background: #fa6;
            pointer-events: auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .filter-add>i {
            color: lightgray;
            font-style: normal;
        }
        .filter-remove {
            border-radius: 100px;
            border: none;
            margin: 6px -23px;
            background: #fa6;
            line-height: 12px;
        }
        .filter-remove:hover {
            background: #fff;
        }
        .filter-title {
            width: 80px;
            padding: 6px;
            text-align: right;
            font-family: monospace;
            color: #666;
            display: inline-block;
            background: #fa6;
            border-top-left-radius: 2px;
            border-bottom-left-radius: 2px;
        }
        .filter-input {
            width: calc(100% - 320px);
            background: #eee;
            padding: 6px;
            font-family: monospace;
            box-sizing: border-box;
            border: none;
            outline: none;
            margin-bottom: 1px;
            border-top-right-radius: 2px;
            border-bottom-right-radius: 2px;
        }
        .filter-input:focus {
            background: #fea;
        }
        .filter-input.invalid {
            background-color: #fdd;
        }
        .dropzone {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            color: silver;
            text-align: center;
            z-index: 9999;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: monospace;
            font-size: 18px;
        }
        .drop-ready {
            background: rgba(240, 240, 255, 0.8);
        }
        .progress-bar {
            width: 200px;
            height: 4px;
            background: #fea;
            border-radius: 2px;
            overflow: hidden;
        }
        .progress-fill {
            width: 0%;
            height: 100%;
            background: #fa6;
        }
        .select-columns-button {
            position: fixed;
            top: 10px;
            right: 20px;
            z-index: 1000;
            background: #fa6;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .select-columns-items {
            position: absolute;
            top: 100%;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            padding: 10px;
            max-height: 300px;
            overflow-y: auto;
            display: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            min-width: 200px;
            text-align: left;
        }
        .select-columns-items-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            font-family: monospace;
            font-size: 12px;
        }
        .merge-dialog {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 9999;
        }
        .merge-dialog-content {
            background: white;
            padding: 20px;
            border-radius: 4px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            width: 80%;
            max-width: 600px;
        }
        .merge-textarea {
            width: 100%;
            height: 200px;
            margin: 10px 0;
            padding: 8px;
            box-sizing: border-box;
            font-family: monospace;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .merge-dialog-buttons {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 15px;
        }
        .merge-button, .cancel-button {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        .merge-button {
            background: #fa6;
            font-weight: bold;
        }
        .merge-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .cancel-button {
            background: #eee;
        }
        .text-editor-toggle {
            outline: none;
            position: absolute;
            top: $;
            left: 0;
            font-family: monospace;
            font-size: 8px;
            padding: 1px;
            background: #eee;
            border: 1px solid #ccc;
            border: none;
            z-index: 10;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <div class="main-container"></div>
    <script>
        // Конфигурационные константы
        const CONSTANTS = {
            COLORS: {
                'null or empty string object': 'gray',
                'basic string object': 'black',
                'javascript object': 'green',
                'unif resource l': 'navy',
                'datetime': 'green',
                'float': 'blue',
                'int': 'navy',
                'hx': 'green',
                'bool': 'red'
            },
            WIDTHS: {
                'null or empty string object': 3,
                'basic string object': 6,
                'javascript object': 10,
                'unif resource l': 10,
                'datetime': 6,
                'float': 5,
                'int': 3,
                'hx': 4,
                'bool': 6
            },
            LINE_HEIGHT: 24,
            PADDING: 6,
            SCROLLBAR_WIDTH: 10
        };

        // Утилиты для работы с CSV
        class CSVParser {
            static parseCSV(text) {
                text = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n'); // Нормализуем переносы
                
                const lines = [];
                let currentLine = [];
                let currentField = '';
                let inQuotes = false;
                
                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    
                    if (char === '"') {
                        if (inQuotes && text[i+1] === '"') {
                            currentField += '"';
                            i++;
                        } else {
                            inQuotes = !inQuotes;
                        }
                    } else if ((char === ',' || char === '\t' || char === ';' || char === '|') && !inQuotes) {
                        currentField = currentField.replace(/[\n\r]/g, ' ').trim();
                        currentLine.push(currentField);
                        currentField = '';
                    } else if (char === '\n' && !inQuotes) {
                        currentField = currentField.replace(/[\n\r]/g, ' ').trim();
                        currentLine.push(currentField);
                        lines.push(currentLine);
                        currentLine = [];
                        currentField = '';
                    } else {
                        currentField += char;
                    }
                }
                
                if (currentField !== '' || text[text.length-1] === ',') {
                    currentField = currentField.replace(/[\n\r]/g, ' ').trim();
                    currentLine.push(currentField);
                }
                if (currentLine.length > 0) {
                    lines.push(currentLine);
                }
                
                return lines;
            }

            static getType(val) {
                if (typeof(val) !== 'string') {
                    val = '' + val;
                }
                if (val === 'null' || val === 'undefined') {
                    return 'null or empty string object';
                }
                let detected = 'basic string object';
                try {
                    JSON.parse(val);
                    detected = 'javascript object';
                } catch (e) {}
                try {
                    new URL(val);
                    detected = 'unif resource l';
                } catch (e) {}
                if (new Date(val) instanceof Date && !isNaN(new Date(val))) detected = 'datetime';
                if (/^\d+\.\d+$/.test(val)) detected = 'float';
                if (parseInt(val) == val) detected = 'int';
                if (val[0] === '0' && parseInt(val, 16) == val) detected = 'hx';
                if (val.toLowerCase() === 'true' || val.toLowerCase() === 'false') detected = 'b';

                return detected;
            }

            static parseTypes(lines) {
                let types = [];
                for (let j = 0; j < lines[0].length; j++) {
                    types.push('b');
                }
                for (let i = 1; i < Math.min(100, lines.length); i++) {
                    let items = lines[i];
                    for (let j = 0; j < items.length; j++) {
                        let type = this.getType(items[j]);
                        if (!types[j] || types[j].length < type.length) {
                            types[j] = type;
                        }
                    }
                }
                return types;
            }
        }

        // Текстовый редактор для редактирования ячеек
        class TextEditor {
            constructor(container = document.body) {
                this.textarea = document.createElement('textarea');
                this.textarea.className = 'text-editor';
                container.appendChild(this.textarea);
                this.textarea.hidden = true;
                this.editStart = -1;
                this.editEnd = -1;
                this.hiddenColumns = [];
                
                // Настройка стилей
                const fontSize = ((CONSTANTS.LINE_HEIGHT - CONSTANTS.PADDING * 2) | 0) + 'px';
                this.textarea.style['font-size'] = fontSize;
                
                this.textarea.style['padding'] = `1px ${CONSTANTS.PADDING}px`;
                this.textarea.style['line-height'] = CONSTANTS.LINE_HEIGHT + 'px';
                
                // Обработчики событий
                this.textarea.addEventListener('change', () => this.applyChanges());
                this.textarea.addEventListener('keydown', (e) => this.handleKeyDown(e));
                this.textarea.addEventListener('paste', e => this.handlePaste(e));

                // Переключатель вида
                this.formatMode = 'table';
                this.formatToggle = document.createElement('select');
                this.formatToggle.size = 2;
                this.formatToggle.innerHTML = `<option value="table" selected>Tbl</option>
                                               <option value="csv">CSV</option>`;
                this.formatToggle.className = 'text-editor-toggle';
                container.appendChild(this.formatToggle);
                this.formatToggle.hidden = true;

                // Следим за изменением режима, чтобы обновить отображение
                this.formatToggle.addEventListener('change', () => {
                    // Перегенерируем значение в новом формате
                    this.formatMode = this.formatToggle.value;
                    const lines = CSVParser.parseCSV(this.textarea.value);
                    this.textarea.value = this.formatCells(lines, this.widths);
                    this.resize();
                });
            }

            formatCellsTable(content, widths) {
                const visibleIndices = this.hiddenColumns.map((h, i) => !h);
                const visibleWidths = widths.filter((_, i) => visibleIndices[i]);
                const formatMap = this.columnFormats || [];

                return content.map(line => {
                    const visibleCells = line.filter((_, idx) => visibleIndices[idx]);
                    return visibleCells.map((cell, visIdx) => {
                        // Найдём исходный индекс колонки
                        let origIdx = -1;
                        let seen = 0;
                        for (let i = 0; i < visibleIndices.length; i++) {
                            if (visibleIndices[i]) {
                                if (seen === visIdx) {
                                    origIdx = i;
                                    break;
                                }
                                seen++;
                            }
                        }
                        let cellText = String(cell || '');
                        if (origIdx !== -1) {
                            const fmt = formatMap[origIdx];
                            if (fmt && fmt !== 'auto') {
                                const digits = (fmt.split('.')[1] || '').length;
                                cellText = (parseFloat(cell) || 0).toFixed(digits);
                            }
                        }
                        const targetWidth = visibleWidths[visIdx] || cellText.length;
                        return cellText.padEnd(targetWidth);
                    }).join('|');
                }).join('\n');
            }

            formatCellsCSV(content) {
                return content.map(line => {
                    const visibleLine = line.filter((_, index) => !this.hiddenColumns[index]);
                    return visibleLine.map(cell => {
                        const str = String(cell || '');
                        // Экранирование CSV: оборачиваем в кавычки, если есть запятые, кавычки, переносы
                        if (str.includes('"') || str.includes(',') || str.includes('\n')) {
                            return `"${str.replace(/"/g, '""')}"`;
                        }
                        return str;
                    }).join(',');
                }).join('\n');
            }

            formatCells(content, widths) {
                if (this.formatMode === 'csv') {
                    return this.formatCellsCSV(content);
                } else {
                    return this.formatCellsTable(content, widths);
                }
            }

            showEditArea(position, size, content, widths) {
                this.textarea.hidden = false;
                this.textarea.style.width = size.width + 'px';
                this.textarea.style.top = position.top + 'px';
                this.textarea.style.height = size.height + 'px';
                if (content) {
                    const cleanedContent = content.map(line => 
                        line.map(cell => String(cell || '').replace(/[\n,]/g, '').trim())
                    );
                    
                    this.textarea.value = this.formatCells(cleanedContent, widths, this.hiddenColumns);
                }
                this.textarea.focus();
                this.textarea.select();

                this.widths = widths;

                this.formatToggle.hidden = false;
                this.formatToggle.style.left = this.textarea.style.left;
                this.formatToggle.style.top = (position.top + size.height) + 'px';

                this.onEditorOpen?.();
            }

            hide() {
                this.textarea.hidden = true;
                this.formatToggle.hidden = true;
            }

            isOpen() {
                return !this.textarea.hidden;
            }

            setEditRange(start, end) {
                this.editStart = start;
                this.editEnd = end;
            }

            applyChanges() {
                if (this.textarea.hidden) return;
                this.hide();

                if (this.textarea.value.trim() === '') return;

                if (this.onEditorChange) {
                    let lines = CSVParser.parseCSV(this.textarea.value);

                    for (let i = 0; i < lines.length; i++) {
                        let line = lines[i],
                            newLine = [];
                        let columnsCount = Math.max(this.hiddenColumns.length, line.length);

                        for (let j = 0; j < columnsCount; j++) {
                            let hidden = this.hiddenColumns[j];
                            if (hidden) {
                                newLine.push(null);
                            } else {
                                newLine.push(line.shift());
                            }
                        }
                        lines[i] = newLine;
                    }
                    this.onEditorChange(lines);
                }
            }

            handleKeyDown(e) {
                if (e.key == 'Tab') {
                    e.preventDefault();
                    var start = this.textarea.selectionStart;
                    var end = this.textarea.selectionEnd;
                    // set textarea value to: text before caret + tab + text after caret
                    this.textarea.value = this.textarea.value.substring(0, start) + "\t" + this.textarea.value.substring(end);
                    // put caret at right position again
                    this.textarea.selectionStart = this.textarea.selectionEnd = start + 1;
                }

                if (e.key === "Enter" && !e.shiftKey) {
                    e.preventDefault();
                    this.applyChanges();
                } else if (e.key === "Enter" || e.key === "Backspace") {
                    this.resize();
                } else if (e.key === 'Escape') {
                    this.hide();
                }
            }

            resize() {
                setTimeout(() => {
                    const linesCount = this.textarea.value.split('\n').length;
                    this.textarea.style.height = (linesCount * CONSTANTS.LINE_HEIGHT) + 'px';
                }, 1);
            }

            handlePaste(e) {
                const pastedText = e.clipboardData.getData('text/plain');
                
                if (pastedText.split('\n').length > 5) {
                    e.preventDefault();
                    
                    const currentValue = this.textarea.value;
                    const beforeSelection = currentValue.substring(0, this.textarea.selectionStart);
                    const afterSelection = currentValue.substring(this.textarea.selectionEnd);
                    let result = beforeSelection + pastedText + afterSelection;

                    if (this.onEditorChange) {
                        let lines = CSVParser.parseCSV(result);
                        this.hide();
                        this.onEditorChange(lines);
                        return;
                    }
                }
                // Для небольших вставок - стандартное поведение
                this.resize();
            }
        }

        class InputWithAutocomplete {
            constructor(container, className, placeholder = '...') {
                this.input = document.createElement('input');
                this.input.type = 'text';
                this.input.className = className;
                this.input.placeholder = placeholder;
                
                container.appendChild(this.input);

                this.autocomplete = [];

                this.input.addEventListener('keyup', e => {
                    if (e.key.startsWith('Arrow')) return;

                    if (e.key !== 'Backspace') {
                        let incomplete = this.suggest();

                        if (!incomplete) {
                            this.fixTypos();
                        }
                    }

                    let isValid = this.onChange(this.input.value);
                    this.input.classList.toggle('invalid', !isValid && this.input.value);
                });
            }

            suggest() {
                const cursorPos = this.input.selectionStart;
                const fullText = this.input.value;

                if (cursorPos < fullText.length && fullText[cursorPos].match(/[\w"']/)) {
                    return false;
                }
                
                const textBeforeCursor = fullText.substring(0, cursorPos);
                const textAfterCursor = fullText.substring(cursorPos);
                const wordMatch = textBeforeCursor.match(/([\w"']+)$/);
                if (!wordMatch) return;

                const partialWord = wordMatch[1];
                const wordStart = wordMatch.index;
                
                for (let item of this.autocomplete) {
                    if (item.toLowerCase().startsWith(partialWord.toLowerCase())) {
                        const rest = item.substring(partialWord.length);
                        
                        this.input.value = textBeforeCursor + rest + textAfterCursor;
                        this.input.setSelectionRange(
                            wordStart + partialWord.length, 
                            wordStart + item.length,
                            'backward' // Выделение в обратном направлении (для удобства замены)
                        );
                        
                        return true;
                    }
                }
            }

            fixTypos() {
                const text = this.input.value;
                let result = '';
                let currentWord = '';

                for (let i = 0; i < text.length; i++) {
                    const char = text[i];
                    
                    // Если это буква - добавляем к текущему слову
                    if (/[a-zA-Z]/.test(char)) {
                        currentWord += char;
                    } else {
                        // Если нашли не-буквенный символ - обрабатываем накопленное слово
                        if (currentWord) {
                            result += this.correctWord(currentWord);
                            currentWord = '';
                        }
                        result += char; // Добавляем сам символ без изменений
                    }
                }

                // Обрабатываем последнее слово, если оно есть
                if (currentWord) {
                    result += this.correctWord(currentWord);
                }

                this.input.value = result;
            }

            correctWord(word) {
                if (word.length < 7) {
                    return word;
                }

                // Ищем точное совпадение без учета регистра
                for (let item of this.autocomplete) {
                    if (item.toLowerCase() === word.toLowerCase()) {
                        return item; // Возвращаем слово с правильным регистром
                    }
                }

                // Ищем похожие слова (максимум 1 опечатка)
                let bestMatch = null;
                let minDistance = Infinity;

                for (let item of this.autocomplete) {
                    const distance = this.levenshteinDistance(word.toLowerCase(), item.toLowerCase());
                    if (distance < minDistance && distance <= 1) {
                        minDistance = distance;
                        bestMatch = item;
                    }
                }

                return bestMatch || word; // Возвращаем исправленное слово или оригинал, если не нашли совпадения
            }

            // Алгоритм Левенштейна для поиска расстояния между строками
            levenshteinDistance(a, b) {
                const matrix = [];
                
                for (let i = 0; i <= b.length; i++) {
                    matrix[i] = [i];
                }
                
                for (let j = 0; j <= a.length; j++) {
                    matrix[0][j] = j;
                }
                
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i-1) === a.charAt(j-1)) {
                            matrix[i][j] = matrix[i-1][j-1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i-1][j-1] + 1,
                                matrix[i][j-1] + 1,
                                matrix[i-1][j] + 1
                            );
                        }
                    }
                }
                
                return matrix[b.length][a.length];
            }

            setAutocompleteList(arr) {
                arr = arr.map(item => item.trim());
                this.autocomplete = arr;
            }
        }

        class FilterList {
            constructor(container = document.body) {
                this.filters = [];
                this.availableFields = [];

                this.div = document.createElement('div');
                this.div.className = 'filter-list';
                container.appendChild(this.div);

                let mergeBtn = document.createElement('button');
                mergeBtn.innerHTML = '<i>ctrl</i>+Merge';
                mergeBtn.className = 'filter-add';
                this.div.appendChild(mergeBtn);
                mergeBtn.onclick = (e) => {
                    this.showMergeDialog();
                };

                let openFilterBtn = document.createElement('button');
                openFilterBtn.innerHTML = '<i>ctrl</i>+Filter';
                openFilterBtn.className = 'filter-add';
                this.div.appendChild(openFilterBtn);
                openFilterBtn.onclick = (e) => {
                    this.toggleFilter();
                };

                let addColumnBtn = document.createElement('button');
                addColumnBtn.innerHTML = '<i>ctrl</i>+Extend';
                addColumnBtn.className = 'filter-add';
                this.div.appendChild(addColumnBtn);
                addColumnBtn.onclick = (e) => {
                    this.addLine(this.genColumnPlaceholder(), 'Column:');
                };

                this.filterLine = this.addLine('*', 'Filter:', false);
                this.filterLine.button.onclick = false;
                this.filterLine.button.innerText = '';
                this.filterLine.container.hidden = true;
            }

            toggleFilter() {
                this.filterLine.container.hidden = false;
                this.filterLine.input.focus();
                this.filterLine.input.select();
            }

            hide() {
                this.filterLine.container.hidden = true;
            }

            setFilteredCount(count) {
                if (count >= 0) {
                    this.filterLine.button.innerText = count;
                } else {
                    this.filterLine.button.innerText = 'err';
                }
            }

            addLine(placeholder, title, needAutocomplete = true) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'filter-line';

                const titleSpan = document.createElement('span');
                titleSpan.className = 'filter-title';
                titleSpan.innerText = title;
                lineDiv.appendChild(titleSpan);

                // Поле фильтра
                const filter = new InputWithAutocomplete(lineDiv, 'filter-input', placeholder);
                filter.setAutocompleteList(this.availableFields);
                filter.onChange = () => this.refilter();
                
                // Кнопка удаления
                const removeBtn = document.createElement('button');
                removeBtn.textContent = '×';
                removeBtn.className = 'filter-remove';
                removeBtn.onclick = () => {
                    if (filter === this.filterLine) {
                        this.filterLine = null;
                    }
                    lineDiv.remove();
                    this.refilter();
                };

                lineDiv.appendChild(removeBtn);
                filter.button = removeBtn;

                this.div.appendChild(lineDiv);

                if (needAutocomplete) {
                    this.filters.push(filter);
                }

                filter.input.focus();
                filter.input.select();
                filter.container = lineDiv;
                filter.title = titleSpan;

                return filter;
            }

            getComputedColumns() {
                let code = '';
                let newVars = new Set();

                for (let filter of this.filters) {
                    let filterStr = filter.input.value;
                    filter.title.innerText = 'Column:';

                    if (filterStr) {
                        let newVar = this.getNewVariableName(filterStr);
                        if (!newVar) {
                        } else {
                            filter.title.innerText = newVar + ':';
                            newVars.add(newVar);
                            code += filterStr + ';\n';
                        }
                    }
                }

                return {
                    code,
                    newVars: Array.from(newVars)
                };
            }

            refilter() {
                let wildcardFilter = this.filterLine.input.value;
                let {code, newVars} = this.getComputedColumns();

                return this.onFilterListChange(wildcardFilter, code, newVars);
            }

            getNewVariableName(filterStr) {
                let eqInd = filterStr.indexOf('=');
                if (eqInd !== -1) {
                    if (filterStr[eqInd + 1] !== '=') {
                        let name = filterStr.substr(0, eqInd).trim();
                        if (/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name)) {
                            return name;
                        }
                    }
                }
            }

            setAutocompleteList(arr) {
                this.availableFields = arr;

                for (let filter of this.filters) {
                    if (typeof(filter.setAutocompleteList) !== 'function') debugger
                    filter.setAutocompleteList(arr);
                }
            }

            genFilterPlaceholder() {
                let fields = this.availableFields;
                if (fields.length === 0) fields = ['Area', 'Bids', 'Count', 'Quality', 'Items'];

                let text = '';

                function rnd() {
                    return arguments[Math.floor(Math.random() * arguments.length)];
                };

                for (let i = 0; i < rnd(1, 2, 3, 5); i++) {
                    if (rnd(true, false)) {
                        let field = rnd(...fields);
                        let op = rnd('==("', '!=("', '.includes("');
                        let val = rnd(field.toLowerCase().substr(0, 2), 'text', 'str');
                        text += field + op + val + '")';
                    } else {
                        let field = rnd(...fields);
                        let op = rnd('==', '!=', '>', '<', '>=', '<=');
                        let val = (Math.random() * 100).toFixed(rnd(0, 0, 2));
                        text += field + op + val;
                    }
                    text += rnd(' && ', ' || ');
                }
                return text.substr(0, text.length - 4);
            }

            genColumnPlaceholder() {
                let fields = this.availableFields;
                if (fields.length === 0) fields = ['Area', 'Bids', 'Count', 'Quality', 'Items'];

                function rnd() {
                    return arguments[Math.floor(Math.random() * arguments.length)];
                };

                let name = rnd('Total', 'NewColumn', ...fields.map(name => name + (this.filters.length + 1)));

                let text = name + ' = ';

                let dot = rnd(0, 0, 2);

                for (let i = 0; i < rnd(1, 2, 3, 5); i++) {
                    let field = rnd(...fields);
                    let op = rnd('*', '/', '*', '/', '**', '%');
                    let val = (Math.random() * 100).toFixed(dot);
                    text += field + op + val;
                    text += rnd(' + ', ' - ');
                }
                return text.substr(0, text.length - 3);
            }

            applyWildcardFilter(lines, filterStr) {
                const parts = filterStr.split('*').map(part => part.toLowerCase()).filter(part => part !== '');
                
                let newTable = [lines[0] || []],
                    indexMap = [0];

                if (parts.length === 0) {
                    return { lines: newTable, indexMap: null };
                }

                for (let i = 1; i < lines.length; i++) {
                    const lineString = lines[i].join(',').toLowerCase();
                    
                    let currentIndex = 0;
                    let allPartsFound = true;

                    for (const part of parts) {
                        const foundIndex = lineString.indexOf(part, currentIndex);
                        if (foundIndex === -1) {
                            allPartsFound = false;
                            break;
                        }
                        currentIndex = foundIndex + part.length;
                    }

                    if (allPartsFound) {
                        newTable.push(lines[i]);
                        indexMap.push(i);
                    }
                }

                return { lines: newTable, indexMap: indexMap };
            }

            showMergeDialog() {
                const dialog = document.createElement('div');
                dialog.className = 'merge-dialog';
                dialog.innerHTML = `
                    <div class="merge-dialog-content">
                        <textarea class="merge-textarea" placeholder="paste CSV here..."></textarea>
                        <div class="merge-dialog-buttons">
                            <button class="merge-button" disabled>Merge</button>
                            <button class="cancel-button">Cancel</button>
                        </div>
                    </div>
                `;
                
                document.body.appendChild(dialog);
                
                const textarea = dialog.querySelector('.merge-textarea');
                const mergeButton = dialog.querySelector('.merge-button');
                const cancelButton = dialog.querySelector('.cancel-button');
                
                let mergeData = null;
                
                textarea.addEventListener('input', () => {
                    try {
                        mergeData = CSVParser.parseCSV(textarea.value);
                        mergeButton.disabled = mergeData.length === 0;
                    } catch (error) {
                        mergeButton.disabled = true;
                        mergeData = null;
                    }
                });
                
                mergeButton.addEventListener('click', () => {
                    if (mergeData && this.onMergeTables) {
                        this.onMergeTables(mergeData);
                        document.body.removeChild(dialog);
                    }
                });
                
                cancelButton.addEventListener('click', () => {
                    document.body.removeChild(dialog);
                });
                
                setTimeout(() => textarea.focus(), 100);
            }

        }


        // Основной компонент таблицы
        class TableView {
            constructor(container = document.body) {
                this.canvas = document.createElement('canvas');
                this.canvas.className = 'tableview-canvas';
                container.appendChild(this.canvas);
                this.ctx = this.canvas.getContext('2d');

                this.lines = [];
                this.types = [];
                this.widths = [];
                this.indexMap = [];
                this.offsetLine = 0;
                this.offsetX = 0;
                this.selectionStart = -1;
                this.selectionEnd = -1;
                this.charWidth = null;
                this.maxLines = null;
                this.totalWidth = 0;
                this.totalHeight = 0;
                this.scrollTopOffset = 0;
                this.hiddenColumns = [];

                const fontSize = CONSTANTS.LINE_HEIGHT - CONSTANTS.PADDING * 2;
                this.ctx.font = fontSize + 'px monospace';
                this.charWidth = this.ctx.measureText('M').width;

                this.onResize();
                window.addEventListener('resize', () => this.onResize());
                window.addEventListener('orientationchange', () => {
                    // Ждем завершения изменения ориентации
                    setTimeout(() => this.onResize(), 100);
                });
            }

            onResize() {
                const container = this.canvas.parentElement;
                const width = container.clientWidth;
                let height = container.clientHeight;

                const pixelRatio = window.devicePixelRatio || 1;
                // Устанавливаем внутреннее разрешение с учетом pixelRatio
                this.canvas.width = width * pixelRatio;
                this.canvas.height = height * pixelRatio;
                
                // Устанавливаем CSS размеры
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';
                
                // Масштабируем контекст
                this.ctx.scale(pixelRatio, pixelRatio);
                
                // Сохраняем размеры для расчетов
                this.displayWidth = width;
                this.displayHeight = height;

                // Пересчитываем максимальное количество строк
                if (window.visualViewport) {
                    height *= window.visualViewport.scale;
                }
                
                this.maxLines = Math.floor(height / CONSTANTS.LINE_HEIGHT);

                this.draw();
            }

            setScrollValue(xval, yval) {
                xval /= this.totalWidth;
                this.offsetX = Math.floor(xval * this.totalWidth);

                this.scrollTopOffset = yval % CONSTANTS.LINE_HEIGHT;

                yval /= this.totalHeight;
                let line = Math.floor(yval * this.lines.length);

                this.offsetLine = line;

                this.draw();
            }

            setLines(lines, types, indexMap) {
                this.lines = lines;
                this.types = types;
                this.indexMap = indexMap || Array.from({ length: lines.length }, (_, i) => i);

                this.widths = [];
                for (let type of this.types) {
                    this.widths.push(CONSTANTS.WIDTHS[type] || 10);
                }
                
                this.draw();
            }

            draw() {
                this.canvas.width = this.canvas.width;

                if (!this.lines || !this.types) return;
                if (!this.lines.length || !this.types.length) return;
                
                const colors = [];
                
                // Подготовка данных для отрисовки
                for (let type of this.types) {
                    colors.push(CONSTANTS.COLORS[type] || 'black');
                }
                
                // Корректировка ширины столбцов
                this.correctWidths(this.widths);
                
                // Расчет полной ширины таблицы
                this.totalWidth = CONSTANTS.PADDING * 2 + (this.charWidth | 0) * this.widths.length + 
                                (this.charWidth | 0) * this.widths.reduce((a, b) => a + b) + 
                                CONSTANTS.SCROLLBAR_WIDTH + 1;

                this.totalHeight = this.lines.length * CONSTANTS.LINE_HEIGHT;

                this.onSetVirtualAreaSize(this.totalWidth, this.totalHeight);

                const fontSize = CONSTANTS.LINE_HEIGHT - CONSTANTS.PADDING * 2;
                this.ctx.font = fontSize + 'px monospace';
                this.charWidth = this.ctx.measureText('M').width;

                let offset = this.offsetLine;

                // Отрисовка строк данных
                for (let i = 1; i < Math.min(this.maxLines, this.lines.length - offset); i++) {
                    const lineIndex = i + offset;
                    const background = this.isSelected(lineIndex) ? '#fea' : 'white';

                    if (this.lines[lineIndex]) {
                        let y = CONSTANTS.LINE_HEIGHT * i - this.scrollTopOffset;
                        this.drawLine(this.lines[lineIndex], y, colors, this.widths, background);
                    } else {
                        debugger;
                    }
                }

                // Отрисовка заголовка
                const background = this.isSelected(0) ? '#fea' : '#fa6';
                this.drawLine(this.lines[0], 0, [], this.widths, background);
            }

            isSelected(lineIndex) {
                if (this.selectionEnd > this.selectionStart) {
                    return lineIndex >= this.selectionStart && 
                        lineIndex <= this.selectionEnd && 
                        this.selectionStart !== -1;
                } else {
                    return lineIndex <= this.selectionStart && 
                        lineIndex >= this.selectionEnd && 
                        this.selectionStart !== -1;
                }
            }

            clearSelection() {
                this.selectionStart = -1;
                this.selectionEnd = -1;
                if (this.lines) {
                    this.draw();
                }
            }

            startSelection(e) {
                // Выделение строки
                this.selectionStart = this.getLineIndexFromMouse(e);
                this.selectionEnd = this.selectionStart;
                this.draw();
            }

            updateSelection(e) {
                if (!this.lines) return;

                // Выделение диапазона
                if (this.selectionStart === -1) return;

                const lineIndex = this.getLineIndexFromMouse(e);
                this.selectionEnd = lineIndex;
                this.draw();
            }

            finishSelection(e) {
                // Нормализация диапазона выделения
                if (this.selectionEnd < this.selectionStart) {
                    [this.selectionStart, this.selectionEnd] = 
                    [this.selectionEnd, this.selectionStart];
                }
            }

            isSelecting() {
                return this.selectionStart !== -1;
            }

            correctWidths(widths) {
                // заголовки обрабатываем отдельно
                for (let j = 0; j < 1; j++) {
                    const items = this.lines[j];
                    if (items !== undefined) {
                        for (let i = 0; i < items.length; i++) {
                            let item = '' + items[i];
                            if (widths[i] < item.length) {
                                widths[i] = item.length;
                            }
                        }
                    }
                }

                let offset = this.offsetLine;

                for (let j = offset; j < Math.min(offset + this.maxLines, this.lines.length); j++) {
                    const items = this.lines[j];
                    if (items !== undefined) {
                        for (let i = 0; i < items.length; i++) {
                            let item = '' + items[i];
                            if (widths[i] < item.length) {
                                widths[i] = item.length;
                            }
                        }
                    }
                }
            }

            drawLine(items, y, colors, widths, background) {
                let x = CONSTANTS.PADDING - this.offsetX;
                this.ctx.lineWidth = 1;
                this.ctx.textBaseline = 'top';
                
                // Фон строки
                this.ctx.fillStyle = background;
                this.ctx.fillRect(0, y, 4096, CONSTANTS.LINE_HEIGHT);
                
                // Отрисовка ячеек
                items.forEach((text, i) => {
                    if (this.hiddenColumns[i]) return;

                    text = '' + text;
                    const color = colors[i] || 'black';
                    const width = widths[i] || 20;
                    let displayText = String(text);
                    if (i < this.types.length) {
                        if (this.columnFormats && this.columnFormats[i]) {
                            const fmt = this.columnFormats[i];
                            if (fmt !== 'auto' && fmt !== 'hidden' && !isNaN(text)) {
                                const digits = (fmt.split('.')[1] || '').length;
                                displayText = (parseFloat(text) || 0).toFixed(digits);
                            }
                        }
                    }

                    if (displayText.length > width) {
                      displayText = displayText.substring(0, width - 1) + '…';
                    }
                    
                    this.ctx.fillStyle = color;
                    this.ctx.fillText(
                        displayText, 
                        Math.floor(x) + 0.5,
                        Math.floor(y + 1 + CONSTANTS.PADDING) + 0.5
                    );
                    
                    x += width * this.charWidth + this.charWidth;
                });
                
                // Разделитель строк
                this.ctx.strokeStyle = '#f0f0f0';
                this.ctx.beginPath();
                this.ctx.moveTo(0, y + CONSTANTS.LINE_HEIGHT - 0.5);
                this.ctx.lineTo(4096, y + CONSTANTS.LINE_HEIGHT);
                this.ctx.stroke(); 
            }

            getLineIndexFromMouse(e) {
                const rect = this.canvas.getBoundingClientRect();
                const y = e.clientY - rect.top;
                let line = Math.floor(y / CONSTANTS.LINE_HEIGHT) + this.offsetLine;
                return Math.min(line, this.lines.length);
            }
        }

        class ScrollContainer {
            constructor(container = document.body) {
                this.scrollContainer = document.createElement('div');
                this.scrollContainer.className = 'scroll-container';
                this.virtualArea = document.createElement('div');
                this.virtualArea.className = 'virtual-area';
                this.scrollContainer.appendChild(this.virtualArea);
                container.appendChild(this.scrollContainer);

                this.scrollContainer.addEventListener('scroll', () => {
                    const scrollX = this.scrollContainer.scrollLeft;
                    const scrollY = this.scrollContainer.scrollTop;
                    this.onScroll(scrollX, scrollY);
                });
            }

            setVirtualAreaSize(width, height) {
                this.virtualArea.style.width = width + 'px';
                this.virtualArea.style.height = height + 'px';
            }
        }

        class CSVFileDropzone {
            constructor(container = document.body) {
                this.onDropStart = null;
                this.onDropProgress = null;
                
                this.dropzone = document.createElement('div');
                this.dropzone.className = 'dropzone';
                this.dropzone.innerText = 'drop .csv here\nmax size 2GB';
                
                container.appendChild(this.dropzone);

                container.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.dropzone.classList.add('drop-ready');
                });
                
                container.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    this.dropzone.classList.remove('drop-ready');
                });
                
                container.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.dropzone.classList.remove('drop-ready');
                    this.showProgress();
                    setTimeout((files) => this.handleFileDrop(files), 300, e.dataTransfer.files);
                });
            }
            
            handleFileDrop(files) {
                if (files.length === 0) return;

                const file = files[0];
                if (!file.name.toLowerCase().endsWith('.csv')) {
                    this.dropzone.innerText = 'drop .csv here\nmax size 2GB';
                    return;
                }
                
                const reader = new FileReader();
                
                reader.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percent = (e.loaded / e.total) * 100;
                        this.updateProgress(percent);
                    }
                };
                
                reader.onload = (e) => {
                    this.completeProgress(e.target.result);
                };
                
                reader.onerror = (e) => {
                    this.dropzone.innerText = 'drop .csv here\nmax size 2GB';
                };
                
                reader.readAsText(file);
            }

            showProgress() {
                this.dropzone.innerHTML = '<div class="progress-bar"><div class="progress-fill"></div></div>';
                this.progressFill = this.dropzone.querySelector('.progress-fill');
                this.progressFill.style.width = '0%';
            }

            updateProgress(percent) {
                if (this.progressFill) {
                    this.progressFill.style.width = percent + '%';
                }
            }

            completeProgress(data) {
                this.updateProgress(100);
                setTimeout((data) => {
                    this.hide();

                    if (this.onDrop) {
                        this.onDrop(data);
                    }
                }, 300, data);
            }

            hide() {
                this.dropzone.hidden = true;
                this.dropzone.style.display = 'none';
            }
        }

        function isMobile() {
            return 'ontouchstart' in window || window.navigator.maxTouchPoints > 0;
        }

        class ColumnSelector {
            constructor(container) {
                this.container = container;
                this.columns = [];
                this.formats = []; // вместо selectedColumns — храним форматы
                this.onChange = null;

                let button = document.createElement('button');
                button.innerHTML = '≡';
                button.className = 'select-columns-button';

                this.panel = document.createElement('div');
                this.panel.className = 'select-columns-items';

                button.appendChild(this.panel);
                this.container.appendChild(button);

                button.addEventListener('mouseenter', () => this.show());
                button.addEventListener('mouseleave', (e) => {
                    if (!this.panel.contains(e.relatedTarget)) {
                        this.hide();
                    }
                });

                this.panel.addEventListener('mouseleave', (e) => {
                    if (!button.contains(e.relatedTarget)) {
                        this.hide();
                    }
                });
            }

            show() {
                this.updatePanel();
                this.panel.style.display = 'block';
            }

            hide() {
                this.panel.style.display = 'none';
            }

            updatePanel() {
                this.panel.innerHTML = '';

                const formatOptions = [
                    { value: 'hidden', label: 'Hide' },
                    { value: 'auto',     label: 'Free' },
                    { value: '0',            label: '0' },
                    { value: '0.0',        label: '0.0' },
                    { value: '0.00',     label: '0.00' },
                    { value: '0.000',    label: '0.000' },
                ];

                this.columns.forEach((columnName, index) => {
                    const container = document.createElement('div');
                    container.className = 'select-columns-items-item';

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = columnName;
                    nameSpan.style.marginRight = '6px';
                    nameSpan.style.flex = '1';

                    const select = document.createElement('select');
                    select.style.fontSize = '12px';
                    select.style.fontFamily = 'monospace';

                    formatOptions.forEach(opt => {
                        const option = document.createElement('option');
                        option.value = opt.value;
                        option.textContent = opt.label;
                        select.appendChild(option);
                    });

                    // Устанавливаем текущее значение
                    select.value = this.formats[index] || 'auto';

                    select.addEventListener('change', () => {
                        this.formats[index] = select.value;
                        if (this.onChange) {
                            this.onChange(this.getHiddenColumns(), this.getColumnFormats());
                        }
                    });

                    container.appendChild(nameSpan);
                    container.appendChild(select);
                    this.panel.appendChild(container);
                });
            }

            getHiddenColumns() {
                return this.formats.map(fmt => fmt === 'hidden');
            }

            getColumnFormats() {
                // Возвращает объект вида { 'Price': '0.00', ... }
                const result = [];
                this.columns.forEach((col, i) => {
                    result.push(this.formats[i] === 'hidden' ? 'auto' : this.formats[i]);
                });
                return result;
            }

            setColumns(columns) {
                const oldColumns = this.columns;
                this.columns = columns;

                const newFormats = [];

                columns.forEach((_, index) => {
                    // По умолчанию — автоформат
                    newFormats[index] = 'auto';
                });

                // Сохраняем предыдущие форматы для совпадающих колонок
                oldColumns.forEach((oldCol, oldIndex) => {
                    const newIndex = columns.indexOf(oldCol);
                    if (newIndex !== -1 && oldIndex < this.formats.length) {
                        newFormats[newIndex] = this.formats[oldIndex];
                    }
                });

                this.formats = newFormats;
                this.updatePanel();

                if (this.onChange) {
                    this.onChange(this.getHiddenColumns(), this.getColumnFormats());
                }
            }
        }

        // Главный контроллер приложения
        class CSVApp {
            constructor(container = document.body) {
                CONSTANTS.LINE_HEIGHT *= window.devicePixelRatio;

                this.lines = [];
                this.types = [];
                this.tableView = new TableView(container);
                this.scrollContainer = new ScrollContainer(container);
                this.textEditor = new TextEditor(this.scrollContainer.virtualArea);
                this.filterList = new FilterList(container);
                this.dropzone = new CSVFileDropzone(container);

                this.columnSelector = new ColumnSelector(container);

                this.columnSelector.onChange = (hiddenColumns, columnFormats) => {
                    this.tableView.hiddenColumns = this.textEditor.hiddenColumns = hiddenColumns;
                    this.tableView.columnFormats = columnFormats;
                    this.textEditor.columnFormats = columnFormats;
                    this.tableView.draw();
                };

                this.scrollContainer.onScroll = (x, y) => {
                    this.tableView.setScrollValue(x, y);
                };

                this.tableView.onSetVirtualAreaSize = (w, h) => {
                    this.scrollContainer.setVirtualAreaSize(w, h);
                };

                this.textEditor.onEditorOpen = () => {
                    this.dropzone.hide();
                    this.tableView.clearSelection();
                };

                this.textEditor.onEditorChange = (changes) => {
                    this.applyTextChanges(changes);
                };

                this.filterList.onFilterListChange = (newFilter, newColumnsCode, newVars) => {
                    return this.applyFilter(newFilter, newColumnsCode, newVars);
                };

                this.filterList.onMergeTables = (mergeData) => {
                    this.mergeTables(mergeData);
                };

                this.dropzone.onDrop = (text) => {
                    this.dropzone.hide();
                    this.lines = CSVParser.parseCSV(text);
                    this.types = CSVParser.parseTypes(this.lines);
                    this.filterList.refilter();
                    this.filterList.setAutocompleteList(this.lines[0]);
                    this.columnSelector.setColumns(this.lines[0])
                };

                // Привязка обработчиков событий
                this.scrollContainer.virtualArea.addEventListener('mousedown', e => this.handleMouseDown(e));
                document.addEventListener('mousemove', e => this.handleMouseMove(e));
                document.addEventListener('mouseup', () => this.handleMouseUp());
                document.addEventListener('keydown', e => this.handleKeyDown(e));
            }

            handleMouseDown(e) {
                if (e.target === this.textEditor.textarea ||
                    e.target === this.textEditor.formatToggle ||
                    this.textEditor.formatToggle.contains(e.target)
                ) {
                  return;
                }
                this.tableView.clearSelection();
                if (this.textEditor.isOpen()) {
                  this.textEditor.applyChanges();
                  this.textEditor.hide();
                  return;
                }
                this.tableView.startSelection(e);
            }

            handleMouseMove(e) {
                this.tableView.updateSelection(e);
            }

            handleMouseUp() {
                if (!this.tableView.isSelecting()) return;
                
                this.tableView.finishSelection();

                // Показ редактора
                if (!isMobile()) {
                    this.showEditor();
                }
            }

            showEditor() {
                const { selectionStart, selectionEnd } = this.tableView;
                
                // 1. Получаем исходные индексы с помощью indexMap
                let sourceStartIndex, sourceEndIndex;
                
                if (!this.tableView.indexMap) {
                    // Если indexMap не существует, создаем его
                    this.tableView.indexMap = Array.from({length: this.tableView.lines.length}, (_, i) => i);
                }
                
                // Дополняем indexMap до нужного размера
                const requiredSize = Math.max(selectionEnd + 1, this.tableView.lines.length);
                if (this.tableView.indexMap.length < requiredSize) {
                    const lastIndex = this.tableView.indexMap.length > 0 ? 
                        this.tableView.indexMap[this.tableView.indexMap.length - 1] : 0;
                    
                    for (let i = this.tableView.indexMap.length; i < requiredSize; i++) {
                        this.tableView.indexMap[i] = lastIndex + (i - this.tableView.indexMap.length + 1);
                    }
                }
                
                sourceStartIndex = this.tableView.indexMap[selectionStart];
                sourceEndIndex = this.tableView.indexMap[selectionEnd];

                // 2. Берем данные для редактора из ОТФИЛЬТРОВАННОГО вида
                const lines = this.tableView.lines.slice(selectionStart, selectionEnd + 1);

                const position = {
                    top: (selectionStart) * CONSTANTS.LINE_HEIGHT
                };

                const size = {
                    width: this.tableView.totalWidth,
                    height: ((selectionEnd - selectionStart + 1) * CONSTANTS.LINE_HEIGHT)
                };

                // 3. Запоминаем в textEditor ИСХОДНЫЕ индексы!
                this.textEditor.setEditRange(sourceStartIndex, sourceEndIndex);
                
                this.textEditor.showEditArea(position, size, lines, this.tableView.widths);
            }

            handleKeyDown(e) {
                if (e.ctrlKey && e.code === 'KeyF') {
                    e.preventDefault();
                    this.textEditor.hide();
                    this.filterList.toggleFilter();
                }

                if (e.ctrlKey && e.code === 'KeyE') {
                    e.preventDefault();
                    this.textEditor.hide();
                    this.filterList.addLine(this.filterList.genColumnPlaceholder());
                }

                if (e.ctrlKey && e.code === 'KeyM') {
                    e.preventDefault();
                    this.filterList.showMergeDialog();
                }

                if (e.code === 'Escape') {
                    this.textEditor.hide();
                    this.filterList.hide();
                }
            }

            applyTextChanges(changes) {
                if (!changes) return;

                const { editStart, editEnd } = this.textEditor;

                let {newVars, code} = this.filterList.getComputedColumns();
                
                // Заменяем или добавляем строки
                for (let i = 0; i < changes.length; i++) {
                    const sourceIndex = editStart + i;
                    let editedLine = changes[i];
                    
                    // Если строка существует в исходном массиве - обновляем её
                    if (sourceIndex < this.lines.length) {
                        let originalLine = this.lines[sourceIndex];
                        
                        // Восстанавливаем значения скрытых колонок из оригинала
                        for (let j = 0; j < originalLine.length; j++) {
                            if (editedLine[j] === null) {
                                editedLine[j] = originalLine[j];
                            }
                        }

                        // Для строки заголовков убираем вычисляемые колонки
                        if (i === 0) {
                            while (true) {
                                let field = editedLine[editedLine.length - 1];
                                if (newVars.includes(field)) {
                                    editedLine.pop();
                                } else {
                                    break;
                                }
                            }
                        }
                        
                        this.lines[sourceIndex] = editedLine;
                    } else { // Добавляем новую строку
                        this.lines.push(editedLine);
                    }
                }

                this.types = CSVParser.parseTypes(this.lines);
                this.filterList.refilter();
                this.filterList.setAutocompleteList(this.lines[0]);
                this.columnSelector.setColumns(this.lines[0]);
            }

            applyFilter(newFilter, newColumnsCode, newVars) {
                let lines = this.lines,
                    types = this.types,
                    indexMap,
                    isValid = true;

                if (newColumnsCode) {
                    let code = this.getFilterCode(newColumnsCode, newVars);
                    try {
                        let modifier = new Function(code)();
                        lines = modifier(this.lines);
                        types = CSVParser.parseTypes(lines);
                    } catch (e) {
                        console.error(code);
                        console.error(e);
                        isValid = false;
                    }
                }

                if (newFilter) {
                    // !!! ВАЖНО: Создаем карту соответствия !!!
                    // Для этого нам нужно знать, какие ИСХОДНЫЕ индексы прошли фильтр.
                    let result = this.filterList.applyWildcardFilter(lines, newFilter);

                    lines = result.lines;
                    indexMap = result.indexMap;
                }

                if (lines) {
                    this.filterList.setFilteredCount(lines.length - 1);
                    this.tableView.setLines(lines, types, indexMap);
                    this.columnSelector.setColumns(lines[0]);
                    return isValid;
                }

                this.filterList.setFilteredCount(-1);
                this.columnSelector.setColumns(this.lines[0]);
                return true;
            }

            getFilterCode(userCode, newColumns) {
                if (!this.lines) {
                    return;
                }

                let names = [...this.lines[0]];

                if (newColumns) {
                    for (let name of newColumns) {
                        names.push(name);
                    }
                }

                // Оборачиваем пользовательский код для правильной обработки
                const wrappedCode = `
return function processTable(table) {
    "use strict";
    let newTable = [[${names.map(name => '"' + name + '"').join(',')}]];
    for (let i = 1; i < table.length; i++) {
        let [${names.join(',')}] = table[i];

        // Пользовательский код выполняется в контексте строки
        ${userCode}
        
        newTable.push([${names.join(',')}]);
    }
    return newTable;
}
                `;

                return wrappedCode;
            }

            mergeTables(mergeData) {
                if (!this.lines?.length || !mergeData?.length) return;

                const baseWidth = this.lines[0].length;
                const mergeWidth = Math.max(...mergeData.map(r => r?.length || 0), 0);
                const targetWidth = baseWidth + mergeWidth;

                // Создаём результат: сначала все исходные строки, дополненные пустыми значениями
                const result = this.lines.map(row => {
                    const newRow = [...(row || [])];
                    while (newRow.length < targetWidth) newRow.push('');
                    return newRow;
                });

                // Мержим данные построчно
                for (let i = 0; i < mergeData.length; i++) {
                    if (i >= result.length) {
                        // Новые строки
                        const newRow = Array(baseWidth).fill('');
                        const src = mergeData[i] || [];
                        for (let j = 0; j < mergeWidth; j++) {
                            newRow.push(src[j] || '');
                        }
                        result.push(newRow);
                    } else {
                        // Дополняем существующие
                        const src = mergeData[i] || [];
                        for (let j = 0; j < mergeWidth; j++) {
                            result[i][baseWidth + j] = src[j] || '';
                        }
                    }
                }

                this.lines = result;
                this.types = CSVParser.parseTypes(this.lines);
                this.filterList.refilter();
                this.columnSelector.setColumns(this.lines[0]);
            }
        }

        // Инициализация приложения
        let app = new CSVApp(document.querySelector('.main-container'));

    </script>
</body>
</html>
